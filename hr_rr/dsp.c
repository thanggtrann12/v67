   /************************************************************
   % 
   %OnSky Inc. Confidential and Proprietary
   %Code written by Thien Phan
   %October, 2020
   %
   %
   %
   %****************************************************************/
#include "main.h"
#include "dsp.h"
#include "lifesos.h"
#include "hr_rr.h"
#include "log.h"

	 
const float32_t firCoeffs32_0P7_20[NUM_TAPS] = {-0.000087, -0.000262, -0.000478, -0.000691, -0.000856, -0.000930, -0.000886, -0.000721, -0.000462, -0.000169, 0.000072, 0.000170, 0.000050, -0.000318, -0.000902, -0.001601, -0.002260, -0.002706, -0.002789, -0.002437, -0.001691, -0.000713, 0.000237, 0.000856, 0.000878, 0.000160, -0.001260, -0.003139, -0.005067, -0.006550, -0.007140, -0.006564, -0.004830, -0.002266, 0.000521, 0.002769, 0.003748, 0.002965, 0.000330, -0.003757, -0.008442, -0.012585, -0.015018, -0.014856, -0.011772, -0.006165, 0.000832, 0.007542, 0.012092, 0.012864, 0.008948, 0.000488, -0.011180, -0.023644, -0.033798, -0.038424, -0.034868, -0.021662, 0.001035, 0.031296, 0.065629, 0.099505, 0.128118, 0.147233, 0.153948, 0.147233, 0.128118, 0.099505, 0.065629, 0.031296, 0.001035, -0.021662, -0.034868, -0.038424, -0.033798, -0.023644, -0.011180, 0.000488, 0.008948, 0.012864, 0.012092, 0.007542, 0.000832, -0.006165, -0.011772, -0.014856, -0.015018, -0.012585, -0.008442, -0.003757, 0.000330, 0.002965, 0.003748, 0.002769, 0.000521, -0.002266, -0.004830, -0.006564, -0.007140, -0.006550, -0.005067, -0.003139, -0.001260, 0.000160, 0.000878, 0.000856, 0.000237, -0.000713, -0.001691, -0.002437, -0.002789, -0.002706, -0.002260, -0.001601, -0.000902, -0.000318, 0.000050, 0.000170, 0.000072, -0.000169, -0.000462, -0.000721, -0.000886, -0.000930, -0.000856, -0.000691, -0.000478, -0.000262, -0.000087};
const float32_t firCoeffs32_0P2_2P0[NUM_TAPS] = {-0.000241, -0.000212, -0.000184, -0.000156, -0.000125, -0.000092, -0.000054, -0.000009, 0.000044, 0.000106, 0.000179, 0.000266, 0.000366, 0.000483, 0.000617, 0.000770, 0.000942, 0.001136, 0.001353, 0.001593, 0.001856, 0.002145, 0.002459, 0.002799, 0.003165, 0.003556, 0.003974, 0.004416, 0.004884, 0.005376, 0.005890, 0.006427, 0.006985, 0.007562, 0.008156, 0.008766, 0.009390, 0.010025, 0.010670, 0.011322, 0.011979, 0.012637, 0.013295, 0.013949, 0.014597, 0.015236, 0.015864, 0.016476, 0.017071, 0.017646, 0.018199, 0.018725, 0.019224, 0.019693, 0.020129, 0.020530, 0.020894, 0.021220, 0.021506, 0.021751, 0.021952, 0.022110, 0.022224, 0.022292, 0.022315, 0.022292, 0.022224, 0.022110, 0.021952, 0.021751, 0.021506, 0.021220, 0.020894, 0.020530, 0.020129, 0.019693, 0.019224, 0.018725, 0.018199, 0.017646, 0.017071, 0.016476, 0.015864, 0.015236, 0.014597, 0.013949, 0.013295, 0.012637, 0.011979, 0.011322, 0.010670, 0.010025, 0.009390, 0.008766, 0.008156, 0.007562, 0.006985, 0.006427, 0.005890, 0.005376, 0.004884, 0.004416, 0.003974, 0.003556, 0.003165, 0.002799, 0.002459, 0.002145, 0.001856, 0.001593, 0.001353, 0.001136, 0.000942, 0.000770, 0.000617, 0.000483, 0.000366, 0.000266, 0.000179, 0.000106, 0.000044, -0.000009, -0.000054, -0.000092, -0.000125, -0.000156, -0.000184, -0.000212, -0.000241}; 
const float32_t firCoeffs32_0P0_1P0[NUM_TAPS] = {0.000769, 0.000787, 0.000816, 0.000857, 0.000910, 0.000975, 0.001053, 0.001144, 0.001248, 0.001365, 0.001497, 0.001642, 0.001801, 0.001973, 0.002160, 0.002360, 0.002574, 0.002801, 0.003040, 0.003293, 0.003558, 0.003835, 0.004123, 0.004421, 0.004730, 0.005049, 0.005377, 0.005712, 0.006055, 0.006405, 0.006760, 0.007120, 0.007484, 0.007851, 0.008220, 0.008591, 0.008961, 0.009330, 0.009697, 0.010061, 0.010421, 0.010776, 0.011124, 0.011466, 0.011799, 0.012124, 0.012438, 0.012741, 0.013032, 0.013310, 0.013575, 0.013825, 0.014060, 0.014279, 0.014481, 0.014666, 0.014833, 0.014981, 0.015111, 0.015222, 0.015312, 0.015383, 0.015434, 0.015465, 0.015475, 0.015465, 0.015434, 0.015383, 0.015312, 0.015222, 0.015111, 0.014981, 0.014833, 0.014666, 0.014481, 0.014279, 0.014060, 0.013825, 0.013575, 0.013310, 0.013032, 0.012741, 0.012438, 0.012124, 0.011799, 0.011466, 0.011124, 0.010776, 0.010421, 0.010061, 0.009697, 0.009330, 0.008961, 0.008591, 0.008220, 0.007851, 0.007484, 0.007120, 0.006760, 0.006405, 0.006055, 0.005712, 0.005377, 0.005049, 0.004730, 0.004421, 0.004123, 0.003835, 0.003558, 0.003293, 0.003040, 0.002801, 0.002574, 0.002360, 0.002160, 0.001973, 0.001801, 0.001642, 0.001497, 0.001365, 0.001248, 0.001144, 0.001053, 0.000975, 0.000910, 0.000857, 0.000816, 0.000787, 0.000769};
const float32_t firCoeffs32_2P0_10[NUM_TAPS] = {-0.000116, -0.000041, 0.000042, 0.000129, 0.000217, 0.000300, 0.000371, 0.000422, 0.000441, 0.000417, 0.000339, 0.000196, -0.000021, -0.000315, -0.000687, -0.001129, -0.001627, -0.002161, -0.002705, -0.003225, -0.003687, -0.004055, -0.004297, -0.004386, -0.004304, -0.004046, -0.003621, -0.003056, -0.002392, -0.001688, -0.001015, -0.000454, -0.000091, -0.000011, -0.000290, -0.000991, -0.002153, -0.003791, -0.005884, -0.008378, -0.011185, -0.014180, -0.017208, -0.020090, -0.022633, -0.024634, -0.025901, -0.026255, -0.025550, -0.023678, -0.020580, -0.016257, -0.010766, -0.004228, 0.003178, 0.011221, 0.019627, 0.028091, 0.036291, 0.043903, 0.050620, 0.056162, 0.060299, 0.062854, 0.063718, 0.062854, 0.060299, 0.056162, 0.050620, 0.043903, 0.036291, 0.028091, 0.019627, 0.011221, 0.003178, -0.004228, -0.010766, -0.016257, -0.020580, -0.023678, -0.025550, -0.026255, -0.025901, -0.024634, -0.022633, -0.020090, -0.017208, -0.014180, -0.011185, -0.008378, -0.005884, -0.003791, -0.002153, -0.000991, -0.000290, -0.000011, -0.000091, -0.000454, -0.001015, -0.001688, -0.002392, -0.003056, -0.003621, -0.004046, -0.004304, -0.004386, -0.004297, -0.004055, -0.003687, -0.003225, -0.002705, -0.002161, -0.001627, -0.001129, -0.000687, -0.000315, -0.000021, 0.000196, 0.000339, 0.000417, 0.000441, 0.000422, 0.000371, 0.000300, 0.000217, 0.000129, 0.000042, -0.000041, -0.000116};
const float32_t firCoeffs32_0P05_1P0[NUM_TAPS] = {0.000787, 0.000806, 0.000838, 0.000880, 0.000936, 0.001004, 0.001085, 0.001180, 0.001289, 0.001412, 0.001549, 0.001701, 0.001868, 0.002049, 0.002244, 0.002454, 0.002678, 0.002917, 0.003169, 0.003434, 0.003713, 0.004005, 0.004308, 0.004623, 0.004949, 0.005285, 0.005631, 0.005986, 0.006349, 0.006718, 0.007094, 0.007476, 0.007861, 0.008250, 0.008641, 0.009034, 0.009426, 0.009818, 0.010207, 0.010594, 0.010976, 0.011353, 0.011724, 0.012087, 0.012441, 0.012786, 0.013120, 0.013443, 0.013753, 0.014049, 0.014330, 0.014597, 0.014847, 0.015080, 0.015295, 0.015492, 0.015670, 0.015828, 0.015966, 0.016084, 0.016181, 0.016256, 0.016311, 0.016343, 0.016354, 0.016343, 0.016311, 0.016256, 0.016181, 0.016084, 0.015966, 0.015828, 0.015670, 0.015492, 0.015295, 0.015080, 0.014847, 0.014597, 0.014330, 0.014049, 0.013753, 0.013443, 0.013120, 0.012786, 0.012441, 0.012087, 0.011724, 0.011353, 0.010976, 0.010594, 0.010207, 0.009818, 0.009426, 0.009034, 0.008641, 0.008250, 0.007861, 0.007476, 0.007094, 0.006718, 0.006349, 0.005986, 0.005631, 0.005285, 0.004949, 0.004623, 0.004308, 0.004005, 0.003713, 0.003434, 0.003169, 0.002917, 0.002678, 0.002454, 0.002244, 0.002049, 0.001868, 0.001701, 0.001549, 0.001412, 0.001289, 0.001180, 0.001085, 0.001004, 0.000936, 0.000880, 0.000838, 0.000806, 0.000787};
	
void filter_data(filter_type_ filter_type,  float32_t* input, float32_t* output, uint32_t size_data)
{	
	uint32_t numBlocks_filter = size_data/BLOCK_SIZE;
	uint32_t modulo = size_data%BLOCK_SIZE;
  arm_fir_instance_f32 S;
  float32_t  *inputF32, *outputF32;
  /* Initialize input and output buffer pointers */
  inputF32 = input;
	//inputF32 = raw_data;
  outputF32 = output;
	float32_t firStateF32[BLOCK_SIZE + NUM_TAPS - 1];
  /* Call FIR init function to initialize the instance structure. */
	if(filter_type == BPF_0P7_20)
	{
		arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)&firCoeffs32_0P7_20[0], &firStateF32[0], BLOCK_SIZE);
	}
	else if(filter_type == BPF_2P0_10)
	{
		arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)&firCoeffs32_2P0_10[0], &firStateF32[0], BLOCK_SIZE);
	}
	else if(filter_type == BPF_0P2_2P0)
	{
		arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)&firCoeffs32_0P2_2P0[0], &firStateF32[0], BLOCK_SIZE);
	}
	else if(filter_type == LPF_1P0)
	{
		arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)&firCoeffs32_0P0_1P0[0], &firStateF32[0], BLOCK_SIZE);
	}
	else if(filter_type == BPF_0P05_1P0)
	{
		arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)&firCoeffs32_0P05_1P0[0], &firStateF32[0], BLOCK_SIZE);
	}
	else
	{
		PLOG("Erorr type filter!");
		return;
	}	
	for(uint32_t i=0; i < numBlocks_filter; i++)
	{
		arm_fir_f32(&S, inputF32 + (i * BLOCK_SIZE), outputF32 + (i * BLOCK_SIZE), BLOCK_SIZE);
	}	
	if(modulo != 0)
	{
		arm_fir_f32(&S, inputF32 + (size_data - modulo), outputF32 + (size_data - modulo), modulo);
	}
}

void fft_f32(float32_t* input_data, float32_t* output_data, uint16_t data_size)
{
	if(data_size != 256 && data_size != 512 && data_size != 1024 && data_size != 2048 &&
		data_size != 4096)
	{
		PLOG("FFT size is incorrect!!!");
		return;
	}	
	
	switch(data_size)
	{
		case 256:
			arm_cfft_f32(&arm_cfft_sR_f32_len256, input_data, 0, 1);
			break;
		case 512:
			arm_cfft_f32(&arm_cfft_sR_f32_len512, input_data, 0, 1);
			break;
		case 1024:
			arm_cfft_f32(&arm_cfft_sR_f32_len1024, input_data, 0, 1);
			break;
		case 2048:
			arm_cfft_f32(&arm_cfft_sR_f32_len2048, input_data, 0, 1);
			break;
		case 4096:
			arm_cfft_f32(&arm_cfft_sR_f32_len4096, input_data, 0, 1);
			break;
		default:
			PLOG("size FFT is incorrect!!!");
			return;
	}	
	arm_cmplx_mag_f32(input_data, output_data, data_size);	
//	for(uint16_t i = 0; i < 10; i++)
//	{
//		printf("%f\r\n", output_data[i]);
//	}	
}

bool isPeak(float32_t arr[], int n, float32_t num, 
                   int i, int j) 
{
		if(i < 0 || j > (n-1)) 
				return false;
    if (i >= 0 && arr[i] >= num) 
        return false; 
    if (j < n && arr[j] > num) 
        return false; 
    return true; 
} 

bool isTrough(float32_t arr[], int n, float32_t num, 
                     int i, int j) 
{ 
		if(i < 0 || j > (n-1)) 
				return false;
    if (i >= 0 && arr[i] < num) 
        return false; 
    if (j < n && arr[j] < num) 
        return false; 
    return true; 
} 

uint16_t find_all_peaks(float32_t arr[], int n, Peak_ peaks[])
{
	uint16_t index_peak = 0;
  for (int i = 0; i < n; i++) 
	{ 
		if (isPeak(arr, n, arr[i], i - 1, i + 1)) 
		{			
			peaks[index_peak].amp = arr[i];
			peaks[index_peak].loc = i;	
			index_peak++;			
		} 
  }
  return index_peak;
}

uint16_t find_all_troughs(float32_t arr[], int n, Peak_ troughs[])
{
	uint16_t index_trough = 0;
  for (int i = 0; i < n; i++) 
	{ 
		if (isTrough(arr, n, arr[i], i - 1, i + 1)) 
		{
			troughs[index_trough].amp = arr[i];
			troughs[index_trough].loc = i;	
			index_trough++;			
		} 
  }
  return index_trough;
}

uint16_t find_size_peaks(float32_t arr[], int n)
{
	uint16_t size_peak = 0;
  for (int i = 0; i < n; i++) 
	{ 
		if (isPeak(arr, n, arr[i], i - 1, i + 1)) 
		{
			size_peak++;
		}
  } 	
	return size_peak;
}

uint16_t find_size_troughs(float32_t arr[], int n)
{
	uint16_t size_trough = 0;
  for (int i = 0; i < n; i++) 
	{ 
		if (isTrough(arr, n, arr[i], i - 1, i + 1)) 
		{
			size_trough++;
		}
  } 	
	return size_trough;
}

float32_t find_agv_k_largest(Peak_ peak[], int n, uint16_t k)
{
	float32_t max[k];
	float32_t max_temp = 10000.0, agv = 0.0;
	uint16_t index_temp = 0;
	uint16_t i,j,temp;
	for(i = 0; i < k; i++)
	{
		max[i] = peak[0].amp;
		for(j = 0; j < n; j++)
		{
				if(peak[j].amp > max[i] && peak[j].amp <= max_temp && j != index_temp)
				{									
					max[i] = peak[j].amp;
					temp = j;						
				}								
		}
		index_temp = temp; //store index max element	
		max_temp = max[i];	
		//PLOG("max_temp = %f", max_temp);
	}
	for(i = 0; i < k; i++)
	{
		agv += max[i];
	}
	agv = agv/k;
	//PLOG("mean = %f", agv);
	return agv;
}


int8_t check_valid_zcn(float32_t arr[], uint16_t x, uint16_t y, float32_t min_th)
{
	int8_t valid_zcn = -1;
	float32_t min = 0;
	for(uint16_t i = x; i <= y; i++)
	{
		if(arr[i] < min_th && arr[i] < min)
		{
			min = arr[i];
			valid_zcn = i;
		}
	}
	return valid_zcn;
}


int8_t check_valid_zcp(float32_t arr[], uint16_t x, uint16_t y, float32_t max_th)
{
	int8_t valid_zcp = -1;
	float32_t max = 0;
	for(uint16_t i = x; i <= y; i++)
	{
		if(arr[i] > max_th && arr[i] > max )
		{
			max = arr[i];
			valid_zcp = i;
		}
	}
	return valid_zcp;
}

float32_t largest(float32_t arr[],uint8_t* loc_max, int n) 
{ 
    int i; 
      
    // Initialize maximum element 
    float32_t max = arr[0]; 
  
    for (i = 1; i < n; i++) 
        if (arr[i] > max) 
				{
            max = arr[i];
						*loc_max = i;
				}
    return max; 
} 

float32_t findMaxPeak(Peak_ *arr,int size)
{
   int i;
   // Initialize maximum element
   float32_t max = arr[0].amp;
   for (i = 1; i < size; i++)
   {
       if (arr[i].amp > max)
		{
           max = arr[i].amp;
		}
   }
   return max;
}

uint16_t findMax(uint16_t *arr, int size)
{
   int i;
   // Initialize maximum element
   uint16_t max = arr[0];
   for (i = 1; i < size; i++)
   {
       if (arr[i] > max)
		{
           max = arr[i];
		}
   }
   return max;
}

float32_t findMaxF(float *arr,int size)
{
   int i;
   // Initialize maximum element
   float32_t max = arr[0];
   for (i = 1; i < size; i++)
   {
       if (arr[i] > max)
		{
           max = arr[i];
		}
   }
   return max;
}
